在前面命令源码解释的 runserver 模块中，我们介绍了 Django 是如何开启一个wsgi服务器，以及又是如何加载 wsgi 应用程序。并且还介绍了一个请求的过程。

今天，我们来扒一扒，路由匹配与试图函数调用的源码。

入口代码在我们的 `django.core.handles.base.BaseHandler()`中

```python
class BaseHandler:
  	def _get_response(self, request):
        """解析url与调用视图函数
        """
        
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
        # 这里得到三个参数，具体的路由匹配我们可以先不研究
        """
        callback: 路由对应的视图函数：<function my_view at 0x1028d5c10> () {}
        callback_args, callback_kwargs：调用视图函数额外的参数
        """

        # 将视图函数放到中间件中去执行
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break

        if response is None:
          	# 设置原子性
            wrapped_callback = self.make_view_atomic(callback)

            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
              	# 调用视图函数，得到一个 response
                response = wrapped_callback(request, *callback_args, **callback_kwargs)
            except Exception as e:
                response = self.process_exception_by_middleware(e, request)
                if response is None:
                    raise

        # Complain if the view returned None (a common error).
        self.check_response(response, callback)

        # If the response supports deferred rendering, apply template
        # response middleware and then render the response
        if hasattr(response, 'render') and callable(response.render):
            for middleware_method in self._template_response_middleware:
                response = middleware_method(request, response)
                # Complain if the template response middleware returned None (a common error).
                self.check_response(
                    response,
                    middleware_method,
                    name='%s.process_template_response' % (
                        middleware_method.__self__.__class__.__name__,
                    )
                )
            try:
                response = response.render()
            except Exception as e:
                response = self.process_exception_by_middleware(e, request)
                if response is None:
                    raise

        return response
```

## 1.`resolve_request`

```python
class BaseHandler:
    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # 默认情况下 没有这个属性，因此不会进入这个方法
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
          	# 往下看看这个对象 
            resolver = get_resolver()
        resolver_match = resolver.resolve(request.path_info)
        request.resolver_match = resolver_match
        # 返回一个正则表达式匹配对象
        # 例如： ResolverMatch(func=wiki_app.views.my_view, args=(), kwargs={}, url_name=None, app_names=[], namespaces=[], route='test/')
        return resolver_match
```

```python
# django.urls.resolvers.py

def get_resolver(urlconf=None):
    if urlconf is None:
      	# 获取 settings 中配置的根路由文件
        # 例如： ROOT_URLCONF = 'django_demo.urls'，这个就是我们创建项目的时候，自动生成的根路由文件
        urlconf = settings.ROOT_URLCONF
    return _get_cached_resolver(urlconf)

@functools.lru_cache(maxsize=None)
def _get_cached_resolver(urlconf=None):
    return URLResolver(RegexPattern(r'^/'), urlconf)

# 返回这样一个实例化对象
class URLResolver:
    def __init__(self, pattern, urlconf_name, default_kwargs=None, app_name=None, namespace=None):
        self.pattern = pattern
        # urlconf_name is the dotted Python path to the module defining
        # urlpatterns. It may also be an object with an urlpatterns attribute
        # or urlpatterns itself.
        self.urlconf_name = urlconf_name
        self.callback = None
        self.default_kwargs = default_kwargs or {}
        self.namespace = namespace
        self.app_name = app_name
        self._reverse_dict = {}
        self._namespace_dict = {}
        self._app_dict = {}
        # set of dotted paths to all functions and classes that are used in
        # urlpatterns
        self._callback_strs = set()
        self._populated = False
        self._local = Local()
    
    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
            for pattern in self.url_patterns:
                try:
                    sub_match = pattern.resolve(new_path)
                except Resolver404 as e:
                    self._extend_tried(tried, pattern, e.args[0].get('tried'))
                else:
                    if sub_match:
                        # Merge captured arguments in match with submatch
                        sub_match_dict = {**kwargs, **self.default_kwargs}
                        # Update the sub_match_dict with the kwargs from the sub_match.
                        sub_match_dict.update(sub_match.kwargs)
                        # If there are *any* named groups, ignore all non-named groups.
                        # Otherwise, pass all non-named arguments as positional arguments.
                        sub_match_args = sub_match.args
                        if not sub_match_dict:
                            sub_match_args = args + sub_match.args
                        current_route = '' if isinstance(pattern, URLPattern) else str(pattern.pattern)
                        self._extend_tried(tried, pattern, sub_match.tried)
                        return ResolverMatch(
                            sub_match.func,
                            sub_match_args,
                            sub_match_dict,
                            sub_match.url_name,
                            [self.app_name] + sub_match.app_names,
                            [self.namespace] + sub_match.namespaces,
                            self._join_route(current_route, sub_match.route),
                            tried,
                        )
                    tried.append([pattern])
            raise Resolver404({'tried': tried, 'path': new_path})
        raise Resolver404({'path': path})
```

