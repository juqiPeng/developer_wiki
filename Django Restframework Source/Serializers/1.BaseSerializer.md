```python
class BaseSerializer(Field):
    """BaseSerializer 类提供了一个可以使用的最小类。
       validated_data、errors、data 这三个属性必须要在调用 is_valid 方法以后才能访问
    """

    def __init__(self, instance=None, data=empty, **kwargs):
        self.instance = instance  # 接受一个 queryset 对象
        
        # 例如 data = request.data, 将用户提交的数据进行反序列化
        if data is not empty:
            self.initial_data = data
        self.partial = kwargs.pop('partial', False)
        self._context = kwargs.pop('context', {})
        kwargs.pop('many', None)
        super().__init__(**kwargs)

    def __new__(cls, *args, **kwargs):
        # 类实例化的时候会先调用这个方法
        # 然后将参数中的 many 参数提取出来
        if kwargs.pop('many', False):
          	# 如果有 many=True，那么就去执行 many_init 方法
            return cls.many_init(*args, **kwargs)
        return super().__new__(cls, *args, **kwargs)

    # Allow type checkers to make serializers generic.
    def __class_getitem__(cls, *args, **kwargs):
        return cls

    # 这个方法主要用于实现序列化多个对象
    @classmethod
    def many_init(cls, *args, **kwargs):
        """
        This method implements the creation of a `ListSerializer` parent
        class when `many=True` is used. You can customize it if you need to
        control which keyword arguments are passed to the parent, and
        which are passed to the child.

        Note that we're over-cautious in passing most arguments to both parent
        and child classes in order to try to cover the general case. If you're
        overriding this method you'll probably want something much simpler, eg:

        @classmethod
        def many_init(cls, *args, **kwargs):
            kwargs['child'] = cls()
            return CustomListSerializer(*args, **kwargs)
        """
        allow_empty = kwargs.pop('allow_empty', None)
        max_length = kwargs.pop('max_length', None)
        min_length = kwargs.pop('min_length', None)
        child_serializer = cls(*args, **kwargs)
        list_kwargs = {
            'child': child_serializer,
        }
        if allow_empty is not None:
            list_kwargs['allow_empty'] = allow_empty
        if max_length is not None:
            list_kwargs['max_length'] = max_length
        if min_length is not None:
            list_kwargs['min_length'] = min_length
        list_kwargs.update({
            key: value for key, value in kwargs.items()
            if key in LIST_SERIALIZER_KWARGS
        })
        meta = getattr(cls, 'Meta', None)
        list_serializer_class = getattr(meta, 'list_serializer_class', ListSerializer)
        return list_serializer_class(*args, **list_kwargs)

    # 重写此方法，实现对反序列化数据的写入
    def to_internal_value(self, data):
        raise NotImplementedError('`to_internal_value()` must be implemented.')
	
  	# 重写此方法，实现对序列化结果的返回
    def to_representation(self, instance):
        raise NotImplementedError('`to_representation()` must be implemented.')

    # 更新实例
    def update(self, instance, validated_data):
        raise NotImplementedError('`update()` must be implemented.')
		
    # 创建新实例
    def create(self, validated_data):
        raise NotImplementedError('`create()` must be implemented.')

    # 保存数据的时候
    def save(self, **kwargs):
      
      	# 调用 save 之前，必须要先调用 is_valid() 设置 _errors 属性
        assert hasattr(self, '_errors'), (
            'You must call `.is_valid()` before calling `.save()`.'
        )

        assert not self.errors, (
            'You cannot call `.save()` on a serializer with invalid data.'
        )

        # Guard against incorrect use of `serializer.save(commit=False)`
        assert 'commit' not in kwargs, (
            "'commit' is not a valid keyword argument to the 'save()' method. "
            "If you need to access data before committing to the database then "
            "inspect 'serializer.validated_data' instead. "
            "You can also pass additional keyword arguments to 'save()' if you "
            "need to set extra attributes on the saved model instance. "
            "For example: 'serializer.save(owner=request.user)'.'"
        )
				
        # 在 save 方法没有
        assert not hasattr(self, '_data'), (
            "You cannot call `.save()` after accessing `serializer.data`."
            "If you need to access data before committing to the database then "
            "inspect 'serializer.validated_data' instead. "
        )

        # 拿到的是已经通过校验的数据
        validated_data = {**self.validated_data, **kwargs}

        # 如果传入了实例，并且又传入了新数据，那么认为可能是需要更新数据。执行更新操作
        if self.instance is not None:
            self.instance = self.update(self.instance, validated_data)
            assert self.instance is not None, (
                '`update()` did not return an object instance.'
            )
        # 否则直接创建新实例
        else:
            self.instance = self.create(validated_data)
            assert self.instance is not None, (
                '`create()` did not return an object instance.'
            )
				# 返回实例（可能是新创建的，也可能是更新过后的）
        return self.instance

    # 这个方法通常是我们在进行反序列化保存数据的时候会调用
    def is_valid(self, raise_exception=False):
      
      	# 序列化器实例化的时候如果没有传递 data= 参数，
        # 那么将认为不需要调用本方法，如果依然强制调用，将会抛出异常
        # 因为没有传入 data 参数的话，说明不需要执行写入操作！！！！！！！！！
        assert hasattr(self, 'initial_data'), (
            'Cannot call `.is_valid()` as no `data=` keyword argument was '
            'passed when instantiating the serializer instance.'
        )

        # 如果实例没有 _validated_data 属性，说明还没进行数据校验，只有执行了校验，才能得到校验过后的数据
        if not hasattr(self, '_validated_data'):
            try:
                # 执行数据校验
                self._validated_data = self.run_validation(self.initial_data)
            # 数据校验抛出异常
            except ValidationError as exc:
              	# 说明校验没通过，将异常信息作为 error 的描述
                self._validated_data = {}
                self._errors = exc.detail
            else:
                self._errors = {}

        # 如果校验的过程中出现了异常，并且设置了 raise_exception=True 标志，则会抛出异常
        if self._errors and raise_exception:
            raise ValidationError(self.errors)

        # self._errors 为空，说明没有错误，则校验通过
        return not bool(self._errors)

    @property
    def data(self):
      	# 如果实例化的时候传入了 data 参数
        # 那么必须要在 is_valid() 方法调用，设置 _validated_data 方法后
        # 才能访问 data 属性
        if hasattr(self, 'initial_data') and not hasattr(self, '_validated_data'):
            msg = (
                'When a serializer is passed a `data` keyword argument you '
                'must call `.is_valid()` before attempting to access the '
                'serialized `.data` representation.\n'
                'You should either call `.is_valid()` first, '
                'or access `.initial_data` instead.'
            )
            raise AssertionError(msg)

        # 如果没有 _data 属性
        if not hasattr(self, '_data'):
          	# 实例不为 None，并且也没有 _errors 属性，可以返回数据！！
            if self.instance is not None and not getattr(self, '_errors', None):
                # 对象实例 --> dict
                self._data = self.to_representation(self.instance)
            # 如果没有实例，说明实例还没有保存，但是数据已经通过了校验，那么我们还是能看到它的序列化数据。对象实例 --> dict
            elif hasattr(self, '_validated_data') and not getattr(self, '_errors', None):
                self._data = self.to_representation(self.validated_data)
            else:
              	# 这可能是字段级别的方法了，略过先。。。
                self._data = self.get_initial()
        return self._data
		
    # 这个属性需要先调用 is_valid() 去设置，当校验不通过的时候才会有值
    @property
    def errors(self):
        if not hasattr(self, '_errors'):
            msg = 'You must call `.is_valid()` before accessing `.errors`.'
            raise AssertionError(msg)
        return self._errors
		
    # 这个属性需要先调用 is_valid() 去设置，校验通过之后才会有值
    @property
    def validated_data(self):
        if not hasattr(self, '_validated_data'):
            msg = 'You must call `.is_valid()` before accessing `.validated_data`.'
            raise AssertionError(msg)
        return self._validated_data

```

```python
# 这个序列化器继承了上面的 base

class Serializer(BaseSerializer, metaclass=SerializerMetaclass):
    default_error_messages = {
        'invalid': _('Invalid data. Expected a dictionary, but got {datatype}.')
    }
		
    # 以字典的形式获取所有的fields：
    
    @cached_property
    def fields(self):
        """
        Example：
        	{
        		'email': EmailField(), 
        		'content': CharField(max_length=200), 
        		'created': DateTimeField()
        	}
        """
        fields = BindingDict(self)
        for key, value in self.get_fields().items():
            fields[key] = value
        return fields

    # 如果字段中没有设置属性：read_only=True，说明是可写的
    @property
    def _writable_fields(self):
        for field in self.fields.values():
            if not field.read_only:
                yield field

    # 如果字段中没有设置属性：write_only=True，说明是可读的
    @property
    def _readable_fields(self):
        for field in self.fields.values():
            if not field.write_only:
                yield field

    # 深拷贝所有的字段
    def get_fields(self):
        return copy.deepcopy(self._declared_fields)

    def get_validators(self):
        """
        Returns a list of validator callables.
        """
        # Used by the lazily-evaluated `validators` property.
        meta = getattr(self, 'Meta', None)
        validators = getattr(meta, 'validators', None)
        return list(validators) if validators else []

    def get_initial(self):
        if hasattr(self, 'initial_data'):
            # initial_data may not be a valid type
            if not isinstance(self.initial_data, Mapping):
                return OrderedDict()

            return OrderedDict([
                (field_name, field.get_value(self.initial_data))
                for field_name, field in self.fields.items()
                if (field.get_value(self.initial_data) is not empty) and
                not field.read_only
            ])

        return OrderedDict([
            (field.field_name, field.get_initial())
            for field in self.fields.values()
            if not field.read_only
        ])

    def get_value(self, dictionary):
        # We override the default field access in order to support
        # nested HTML forms.
        if html.is_html_input(dictionary):
            return html.parse_html_dict(dictionary, prefix=self.field_name) or empty
        return dictionary.get(self.field_name, empty)

    def run_validation(self, data=empty):
        """
        We override the default `run_validation`, because the validation
        performed by validators and the `.validate()` method should
        be coerced into an error dictionary with a 'non_fields_error' key.
        """
        (is_empty_value, data) = self.validate_empty_values(data)
        if is_empty_value:
            return data

        value = self.to_internal_value(data)
        try:
            self.run_validators(value)
            value = self.validate(value)
            assert value is not None, '.validate() should return the validated data'
        except (ValidationError, DjangoValidationError) as exc:
            raise ValidationError(detail=as_serializer_error(exc))

        return value

    def _read_only_defaults(self):
        fields = [
            field for field in self.fields.values()
            if (field.read_only) and (field.default != empty) and (field.source != '*') and ('.' not in field.source)
        ]

        defaults = OrderedDict()
        for field in fields:
            try:
                default = field.get_default()
            except SkipField:
                continue
            defaults[field.source] = default

        return defaults

    def run_validators(self, value):
        """
        Add read_only fields with defaults to value before running validators.
        """
        if isinstance(value, dict):
            to_validate = self._read_only_defaults()
            to_validate.update(value)
        else:
            to_validate = value
        super().run_validators(to_validate)

    def to_internal_value(self, data):
        """
        Dict of native values <- Dict of primitive datatypes.
        """
        if not isinstance(data, Mapping):
            message = self.error_messages['invalid'].format(
                datatype=type(data).__name__
            )
            raise ValidationError({
                api_settings.NON_FIELD_ERRORS_KEY: [message]
            }, code='invalid')

        ret = OrderedDict()
        errors = OrderedDict()
        fields = self._writable_fields

        for field in fields:
            validate_method = getattr(self, 'validate_' + field.field_name, None)
            primitive_value = field.get_value(data)
            try:
                validated_value = field.run_validation(primitive_value)
                if validate_method is not None:
                    validated_value = validate_method(validated_value)
            except ValidationError as exc:
                errors[field.field_name] = exc.detail
            except DjangoValidationError as exc:
                errors[field.field_name] = get_error_detail(exc)
            except SkipField:
                pass
            else:
                set_value(ret, field.source_attrs, validated_value)

        if errors:
            raise ValidationError(errors)

        return ret

    def to_representation(self, instance):
        """
        Object instance -> Dict of primitive datatypes.
        """
        ret = OrderedDict()
        fields = self._readable_fields

        for field in fields:
            try:
                attribute = field.get_attribute(instance)
            except SkipField:
                continue

            # We skip `to_representation` for `None` values so that fields do
            # not have to explicitly deal with that case.
            #
            # For related fields with `use_pk_only_optimization` we need to
            # resolve the pk value.
            check_for_none = attribute.pk if isinstance(attribute, PKOnlyObject) else attribute
            if check_for_none is None:
                ret[field.field_name] = None
            else:
                ret[field.field_name] = field.to_representation(attribute)

        return ret

    def validate(self, attrs):
        return attrs

    def __repr__(self):
        return representation.serializer_repr(self, indent=1)

    # The following are used for accessing `BoundField` instances on the
    # serializer, for the purposes of presenting a form-like API onto the
    # field values and field errors.

    def __iter__(self):
        for field in self.fields.values():
            yield self[field.field_name]

    def __getitem__(self, key):
        field = self.fields[key]
        value = self.data.get(key)
        error = self.errors.get(key) if hasattr(self, '_errors') else None
        if isinstance(field, Serializer):
            return NestedBoundField(field, value, error)
        if isinstance(field, JSONField):
            return JSONBoundField(field, value, error)
        return BoundField(field, value, error)

    # Include a backlink to the serializer class on return objects.
    # Allows renderers such as HTMLFormRenderer to get the full field info.

    @property
    def data(self):
        ret = super().data
        return ReturnDict(ret, serializer=self)

    @property
    def errors(self):
        ret = super().errors
        if isinstance(ret, list) and len(ret) == 1 and getattr(ret[0], 'code', None) == 'null':
            # Edge case. Provide a more descriptive error than
            # "this field may not be null", when no data is passed.
            detail = ErrorDetail('No data provided', code='null')
            ret = {api_settings.NON_FIELD_ERRORS_KEY: [detail]}
        return ReturnDict(ret, serializer=self)

```

